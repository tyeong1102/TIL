### 객체 지향 프로그래밍

- 객체란?

 물리적으로 존재하거나 개념적인 것 중에서 다른 것과 식별 가능한 것. 속성(feild)와 동작(method)로 구성되고 현실 세계의 객체를 소프트웨어 객체로 설계하는 것을 객체 모델링이라고 한다.

- 캡슐화

 객체의 필드와 메소드를 하나로 묶고 구현 내용을 외부에 감추는 것. 필드와 메소드를 보호하는 것이 주된 목적이기 때문에 접근 제한자를 사용한다.

- 상속

 상위 객체의 필드와 메소드를 하위 객체에 물려주어 사용할 수 있게 하는 것.

- 다형성

 사용 방법은 동일하지만, 실행 결과가 다양하게 나옴. 구현을 위해 상속과 인터페이스 구현이 필요하다.

### 객체와 클래스

 객체를 생성하려면 설계도에 해당하는 클래스가 필요하고 그 클래스로부터 생성된 객체를 인스턴스라고 한다.

### 클래스의 구성 멤버

- 필드 : 객체의 데이터를 저장.
    - 필드 vs (로컬)변수
    
    | 구분 | 필드 | (로컬)변수 |
    | --- | --- | --- |
    | 선언 위치 | 클래스 선언 블록 | 생성자, 메소드 선언 블록 |
    | 존재 위치 | 객체 내부에 존재 | 생성자, 메소드 호출 시에만 존재 |
    | 사용 위치 | 객체 내부, 외부 어디든 사용 | 생성자, 메소드 블록 내부에서만 사용 |
    - 필드 사용
    
     필드는 객체의 데이터이므로 객체가 존재하지 않으면 필드도 존재하지 않는다.
    
- 생성자 : new 연산자로 객체를 생성할 때 객체의 초기화 역할.
    - 기본 생성자
    
     모든 클래스는 생성자가 존재하며, 하나 이상 가질 수 있다.
    
    - 생성자 선언
    
     메소드와 유사하나, 리턴 타입이 없고 클래스 이름과 동일하다. 또한 객체마다 다른 값을 가졌을 경우 생성자에서 필드를 초기화 해야한다.
    
    - 생성자 오버로딩
    
     매개변수를 달리하는 생성자 여러 개를 선언하는 것을 말하는데 객체의 필드를 다양하게 초기화하려면 필요하다. new 연산자로 생성자를 호출할 때 제공되는 매개 값의 타입과 수에 따라 실행될 생성자가 결정된다. 오버로딩이 많아질 경우 중복된 코드가 발생하는데, 공통 코드를 한 생성자에 작성하고 this를 통해 생성자를 호출하는 방식으로 가야한다.
    
- 메소드 : 객체가 수행할 동작.
    - 메소드 선언 : 동작을 실행 블록으로 정의.
    
     리턴 타입이 있는 메소드는 return문으로 반드시 리턴값을 지정해야 한다.
    
    - 메소드 호출: 실행 블록을 실제로 실행.
    
     * 가변길이 매개변수
    
    ```java
    int sum(int ... values){} // 매개값드른 자동으로 배열 항목으로 변환되어 사용.
    ```
    
    - 메소드 오버로딩
    
     메소드 이름은 같지만 매개변수 타입, 개수, 순서가 다른 메소드를 여러개 선언하는 것.
    
    System.out.println() 메소드도 오버로딩의 대표적인 예이다.
    
    ```java
    // 매개값 타입에 따가서 오버로딩된 println() 메소드 중 선택.
    void println(){...}
    void println(double x){...}
    void println(int x){...}
    void println(String x){...}
    ```
    

### 필드와 메소드의 선언 방법

- 인스턴스(instance) 멤버 : 객체에 소속된 멤버.
    
     객체 내부에서는 인스턴스 멤버에 접근하기 위해 this를 사용한다.
    
- 정적(static) 멤버 : 메소드 영역의 클래스에 고정적으로 위치하는 멤버.
    - static
        - 객체마다 가지고 있을 필요성이 없는 공용적인 필드.
        - 인스턴스 필드를 이용하지 않는 메소드.
    - 정적 블록 : 복잡한 초기화 작업이 필요할 때.
    
    ```java
    public class Television {
    	static String company = "MyCompany";
    	static String model = "LCD";
    	static String info;
    	static {
    		info = company + "-" + model;
    	}
    }
    
    public class TelevisionExample {
    	public static void main(String args[]){
    		System.out.println(Television.info); // MyCompany-LCD
    	}
    }
    ```
    
    - 인스턴스 멤버 사용 불가
    
     인스턴스 필드나 인스턴스 메소드를 사용할 수 없고 this도 사용할 수 없다. 만약 정적 메소드와 정적 블록에서 인스턴스 멤버를 사용하고 싶다면 객체를 먼저 생성하고 참조 변수로 접근해야 한다.
    
    main() 메소드도 정적 메소드이기 때문에 객체 생성 없이 인스턴스 필드와 메소드를 바로 사용할 수 없는 것이다.
    
    ```java
    // 잘못된 사용
    public static void main(String[] args){
    	speed = 60;
    	run();
    }
    
    // 인스턴스 사용 가능
    public static void main(String[] args){
    	Car myCar = new Car();
    	myCar.speed = 60;
    	myCar.run();
    }
    ```
    
- final 필드와 상수
    - final :  읽기만 가능하고 실행 도중 수정 불가.
        - 필드 선언 시 초기값 대입 - 고정된 값.
        - 생성자에서 초기값 대입 - 객체 생성 시 외부에서 전달된 값으로 초기화.
    - 상수 : 불변의 값을 저장.
    
     객체마다 저장할 필요도 없고, 여러 개의 값을 가지면 안되기에 static final을 사용해야 한다. 
    
    ```java
    static final double PI = 3.14;
    ```
    
    뿐만 아니라 정적 블록에서의 초기화도 가능하다.
    

### 패키지

 클래스의 일부분이며, 글래스를 식별하는 용도로 사용된다.

### Getter와 Setter

- Setter

 직접적인 외부에서의 필드 접근을 막고 메소드를 통해 필드에 접근한다.

- Getter

 외부에서 객체의 필드를 읽을 때 필드값이 객체 외부에서 사용하기에 부적절한 경우, 적절한 값으로 변환해서 리턴할 수 있다.