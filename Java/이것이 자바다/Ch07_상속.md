### 상속

 부모가 자식에게 물려주는 행위를 말하는데 중복되는 코드를 줄여 개발 시간을 단축시키는 것이 목적이고 이로 인해 부보 클래스를 수정하면 모든 자식 클래스에 수정 효과를 가져온다. 타 언어와 달리 Java는 다중 상속을 허용하지 않는다는 특이점이 있다.

### 부모 생성자 호출

- super()

 부모 생성자는 자식 생성자의 맨 첫 줄에 숨겨져 있는 super()에 의해 호출되는데, 이는 컴파일 과정에서 자동 추가되고 부모의 기본 생성자를 호출한다. 만약 부모 클래스에 기본 생성자가 없고 매개변수를 가지는 생성자만 있다면, super(매개값, …)을 해야한다.

### 메소드 재정의

- 메소드 오버라이딩
    - 부모 메소드의 선언부와 동일.
    - 접근 제한을 더 강하게 오버라이딩할 수 없다.
    - 새로운 예외 throws 불가.

 부모 클래스 중 어떤 메소드는 자식 클래스에 사용하기에 부적합할 수 있는데 이때, 상속된 메소드를 자식 클래스에서 재정의 하는 것을 말한다. 이렇게 되면 부모 메소드는 숨겨지고 자식 메소드가 우선적으로 사용된다.

### final

- final 클래스

 최종적인 클래스이므로 더 이상 상속할 수 없는 클래스가 된다.

- final 메소드

 최종적인 메소드이므로 더 이상 오버라이딩할 수 없는 메소드가 된다.

### 다형성

 사용 방법은 동일하지만, 실행 결과가 다양하게 나오는 성질을 말한다. 이를 구현하기 위해서는 자동 타입 변환과 메소드 재정의가 필요하다. 그리고 객체 사용 방법이 동일하다는 것을 동일한 메소드를 가지고 있다는 뜻이다.

- 필드 다형성

 필드 타입은 동일하지만 대입되는 객체가 달라져서 실행 결과가 다양하게 나올 수 있는 것을 말한다.

```java
public class Tire {
	public void roll() {
		System.out.println("회전합니다.");
	}
}

public class HankookTire extends Tire {

	@Override
	public void roll() {
		System.out.println("한국 타이어가 회전합니다.");
	}
}
```

 위의 코드에서도 자동 타입 변환 때문에 HankookTire 객체를 Tire 필드에 대입할 수 있고, 재정의된 roll() 메소드가 호출된다.

- 매개변수 다형성

 다형성 자체가 필드보다는 메소드를 호출할 때 많이 발생하는데, 클래스 타입의 매개변수를 가지고 있을 경우 자식 객체를 제공할 수도 있다.

### 추상 클래스

 추상이란 실체 간에 공통되는 특성을 추출한 것을 말한다. 비슷한 의미로 추상 클래스 또한 실체 클래스들의 공통적인 필드나 메소드를 추출해서 선언한 클래스를 말한다. 공통된 필드와 메소드를 추출해서 만들었기 때문에 new 연산자를 사용해서 객체를 직접 생성할 수 없다. abstract 키워드로 선언하고 자식 객체가 생성될 때 super()로 추상 클래스의 생성자가 호출된다.

- 추상 메소드와 재정의

 추상 메소드는 자식 클래스에서 반드시 재정의(오버라이딩)해야한다. 

### 봉인된 클래스

 Java 15에서 무분별한 자식 클래스 생성을 방지하기 위해 처음 도입된 것이다.

```java
public sealed class Person permits Employee, Manager {...}

public final class Employee extends Person {...}
public non-sealed class Manager extends Person {...}
```

 sealed 키워드를 사용하면, permits 키워드 뒤에 상속 가능한 자식 클래스를 지정해야 한다.

final : 더 이상 상속할 수 없음

non-sealed : 봉인을 해제 (자식클래스 생성 가능)